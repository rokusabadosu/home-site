<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Grid Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #gameCanvas {
            background-color: #3b82f6; /* Changed to blue, same as lakes */
            display: block; /* Removes extra space below canvas */
            width: 100vw;
            height: 100vh;
            cursor: grab; /* Show a grab cursor */
        }
        #gameCanvas:active {
            cursor: grabbing; /* Show a grabbing cursor when dragging */
        }
        #foodCounter, #goldCounter, #healthCounter {
            position: absolute;
            left: 10px;
            color: white;
            font-size: 20px;
            z-index: 10; /* Ensure it's above the canvas */
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7); /* Optional background for better visibility */
            border-radius: 5px;
        }
        #healthCounter {
            top: 10px;
        }
        #foodCounter {
            top: 50px;
        }
        #goldCounter {
            top: 90px; /* Positioned below foodCounter */
        }
        #activeQuestDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 18px;
            z-index: 10;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: none; /* Hidden by default */
        }
        #gameOverScreen, #townScreen, #monsterEncounterScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; /* Initially hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 11; /* Sit on top of everything */
            color: white;
            font-size: 24px;
        }
        #gameOverScreen h2, #townScreen h2, #monsterEncounterScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }
        #gameOverScreen button, #townScreen button, #monsterEncounterScreen button {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
            transition: background-color 0.3s ease;
        }
        #gameOverScreen button:hover, #townScreen button:hover, #monsterEncounterScreen button:hover {
            background-color: #367c39; /* Darker green */
        }
        #townScreen button.bg-red-500, #monsterEncounterScreen button.bg-red-500 {
            background-color: #ef4444; /* Red for close button */
        }
        #townScreen button.bg-red-500:hover, #monsterEncounterScreen button.bg-red-500:hover {
            background-color: #dc2626; /* Darker red */
        }
        .delivery-button {
            background-color: #3498db; /* Blue for delivery buttons */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-bottom: 10px;
            width: 90%; /* Make buttons wider - CHANGED */
            max-width: 500px; /* Increased max width - CHANGED */
            transition: background-color 0.3s ease;
        }
        .delivery-button:hover {
            background-color: #217dbb; /* Darker blue */
        }
        #noDeliveryButton {
            background-color: #6b7280; /* Gray for no delivery */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 10px;
            width: 90%; /* Make buttons wider - CHANGED */
            max-width: 500px; /* Increased max width - CHANGED */
            transition: background-color 0.3s ease;
        }
        #noDeliveryButton:hover {
            background-color: #4b5563; /* Darker gray */
        }

        #messageDisplay {
            position: absolute;
            top: 50%; /* Changed from bottom */
            left: 50%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Adjust for perfect centering */
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 12;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            max-width: 80%; /* Limit width for long messages */
            text-align: center;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .show-message {
            opacity: 1;
            display: flex; /* Explicitly set to flex when showing */
            justify-content: center;
            align-items: center;
        }
        .hide-message {
            opacity: 0;
            /* Transition will handle the fade out, then display: none after transition */
        }
        /* Custom CSS for the Game */
        #gameCanvas {
            background-color: #3b82f6; /* Light gray background */
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden">
    <canvas id="gameCanvas"></canvas>
    <div id="healthCounter">Health: 100</div>
    <div id="foodCounter">Food: 100</div>
    <div id="goldCounter">Gold: 0</div>
    <div id="activeQuestDisplay"></div>

    <div id="gameOverScreen">
        <h2>Game Over</h2>
        <p id="gameOverReason">You have run out of food!</p>
        <button id="restartButton">Restart</button>
    </div>

    <div id="townScreen" class="absolute inset-0 bg-black bg-opacity-80 hidden flex-col justify-center items-center z-20 text-white text-2xl">
        <h2 id="townNameDisplay" class="text-4xl mb-4"></h2>
        <p class="mb-4">Welcome to the town!</p>
        
        <div class="flex flex-col md:flex-row items-center md:items-start justify-center space-y-8 md:space-y-0 md:space-x-8 mb-4 w-full">
            <div class="flex flex-col items-center">
                <label for="foodBuySlider" class="mb-2">Buy Food:</label>
                <input type="range" id="foodBuySlider" min="0" max="0" value="0" step="10" class="w-64 accent-green-500">
                <p id="sliderFoodAmount" class="mt-2">0 Food</p>
                <p id="sliderGoldCost" class="mt-1">0 Gold</p>
                <button id="buyFoodButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 ease-in-out transform hover:scale-105 mt-4">Buy Food</button>
            </div>

            <div class="flex flex-col items-center">
                <label for="healthHealSlider" class="mb-2">Heal Health:</label>
                <input type="range" id="healthHealSlider" min="0" max="0" value="0" step="2" class="w-64 accent-red-500">
                <p id="sliderHealthAmount" class="mt-2">0 Health</p>
                <p id="sliderHealCost" class="mt-1">0 Gold</p>
                <button id="healHealthButton" class="bg-red-500 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 ease-in-out transform hover:scale-105 mt-4">Heal Health</button>
            </div>
        </div>

        <div id="deliveryOptions" class="flex flex-col items-center mb-4 w-full">
            <p class="mb-2">Available Deliveries:</p>
            <button id="deliveryOption1" class="delivery-button"></button>
            <button id="deliveryOption2" class="delivery-button"></button>
            <button id="deliveryOption3" class="delivery-button"></button>
        </div>

        <button id="closeTownButton" class="bg-red-500 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 ease-in-out transform hover:scale-105">Close Town Screen</button>
    </div>

    <div id="monsterEncounterScreen" class="absolute inset-0 bg-black bg-opacity-80 hidden flex-col justify-center items-center z-20 text-white text-2xl">
        <h2 id="monsterName" class="text-4xl mb-4"></h2>
        <p id="monsterHealth" class="mb-2"></p>
        <p id="monsterMessage" class="mb-6 text-xl"></p>
        <div class="flex space-x-4">
            <button id="fightButton" class="bg-red-600 hover:bg-red-800 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 ease-in-out transform hover:scale-105">Fight!</button>
            <button id="runButton" class="bg-blue-600 hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 ease-in-out transform hover:scale-105">Run Away!</button>
        </div>
    </div>

    <div id="messageDisplay" class="hide-message"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gridSize = 30; // Size of each grid cell - increased to make grid bigger
        let playerX, playerY; // Player position in grid coordinates
        let mapWidth = 50; // Map size in grid cells - changed to 50
        let mapHeight = 50; // Map size in grid cells - changed to 50
        let mapData; // 2D array representing the map
        let townNames = {}; // Store town names with their coordinates as keys
        let townCoordinates = []; // Stores {x, y} of all towns

        let viewOffsetX = 0; // Offset for panning the map
        let viewOffsetY = 0;
        let isDragging = false;
        let dragStartX, dragStartY;
        let zoomLevel = 1; // Initial zoom level
        const zoomSpeed = 0.1; // Speed of zooming
        const minZoom = 0.5;
        const maxZoom = 3;

        let foodCount = 100; // Initial food count
        let goldCount = 10; // Initial gold count
        let healthCount = 100; // Initial health count
        const maxFoodCapacity = 100; // Max food player can have
        const maxHealthCapacity = 100; // Max health player can have
        const foodPerGoldUnit = 10; // 10 food for 1 gold (so 1 gold buys 10 food)
        const healthPerGoldUnitHeal = 2; // 2 health for 1 gold (so 0.5 gold per 1 health)

        let currentQuest = null; // Stores { targetX, targetY, reward, targetTownName }
        const deliveryRewardFactor = 2; // Gold per unit distance for delivery quests
        const minDeliveryDistance = 5; // Minimum distance for a delivery quest
        const maxDeliveryAttempts = 10; // Max attempts to find a suitable delivery town

        // Monster encounter variables
        let turnsInHazardousTerrain = 0;
        let isMonsterEncounterActive = false;
        let currentMonster = null; // { name, health, attack, goldReward, foodReward }

        const baseEncounterChance = 0.05; // 5% chance
        const chanceIncreasePerTurn = 0.05; // +5% per successive turn
        const maxEncounterChance = 0.5; // Cap at 50%

        const playerBaseAttack = 20; // Damage player deals
        const playerRunSuccessChance = 0.6; // 60% chance to run successfully
        const runHealthPenalty = 5; // Health lost when running
        const monsterHitHealthLoss = 15; // Health lost when hit by monster
        const monsterHitGoldLoss = 3; // Gold lost when hit by monster
        const noFoodHealthPenalty = 10; // Health lost per turn when food is 0

        const healthCounterDisplay = document.getElementById('healthCounter');
        const foodCounterDisplay = document.getElementById('foodCounter');
        const goldCounterDisplay = document.getElementById('goldCounter');
        const activeQuestDisplay = document.getElementById('activeQuestDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        const gameOverReason = document.getElementById('gameOverReason');
        const messageDisplay = document.getElementById('messageDisplay');
        let messageTimeout;

        // Town screen elements
        const townScreen = document.getElementById('townScreen');
        const townNameDisplay = document.getElementById('townNameDisplay');
        const foodBuySlider = document.getElementById('foodBuySlider');
        const sliderFoodAmountDisplay = document.getElementById('sliderFoodAmount');
        const sliderGoldCostDisplay = document.getElementById('sliderGoldCost');
        const buyFoodButton = document.getElementById('buyFoodButton');
        const closeTownButton = document.getElementById('closeTownButton');

        // New Health Healing elements
        const healthHealSlider = document.getElementById('healthHealSlider');
        const sliderHealthAmountDisplay = document.getElementById('sliderHealthAmount');
        const sliderHealCostDisplay = document.getElementById('sliderHealCost');
        const healHealthButton = document.getElementById('healHealthButton');

        // Delivery quest elements
        const deliveryOptionButtons = [
            document.getElementById('deliveryOption1'),
            document.getElementById('deliveryOption2'),
            document.getElementById('deliveryOption3')
        ];
        // Removed noDeliveryButton element
        let availableQuests = [];

        // Monster encounter screen elements
        const monsterEncounterScreen = document.getElementById('monsterEncounterScreen');
        const monsterNameDisplay = document.getElementById('monsterName');
        const monsterHealthDisplay = document.getElementById('monsterHealth');
        const monsterMessageDisplay = document.getElementById('monsterMessage');
        const fightButton = document.getElementById('fightButton');
        const runButton = document.getElementById('runButton');

        /**
         * Updates the displayed health count.
         */
        function updateHealthCounter() {
            healthCounterDisplay.textContent = `Health: ${Math.floor(healthCount)}`;
        }

        /**
         * Updates the displayed food count.
         */
        function updateFoodCounter() {
            foodCounterDisplay.textContent = `Food: ${Math.floor(foodCount)}`;
        }

        /**
         * Updates the displayed gold count.
         */
        function updateGoldCounter() {
            goldCounterDisplay.textContent = `Gold: ${Math.floor(goldCount)}`;
        }

        /**
         * Shows a message on the screen for a specified duration.
         * @param {string} message - The message to display.
         * @param {number} duration - The duration in milliseconds to display the message.
         */
        function showMessage(message, duration = 2500) {
            clearTimeout(messageTimeout); // Clear any existing timeout
            messageDisplay.textContent = message;
            messageDisplay.style.display = 'flex'; // Set display to flex when showing
            messageDisplay.classList.remove('hide-message');
            messageDisplay.classList.add('show-message');

            messageTimeout = setTimeout(() => {
                messageDisplay.classList.remove('show-message');
                messageDisplay.classList.add('hide-message');
                // After the fade-out, set display to none to remove from layout
                messageDisplay.addEventListener('transitionend', function handler() {
                    if (messageDisplay.classList.contains('hide-message')) {
                        messageDisplay.style.display = 'none';
                        messageDisplay.removeEventListener('transitionend', handler);
                    }
                });
            }, duration);
        }

        /**
         * Updates the active quest display on the top right.
         */
        function updateActiveQuestDisplay() {
            if (currentQuest) {
                activeQuestDisplay.textContent = `Deliver to: ${currentQuest.targetTownName} (${currentQuest.reward} Gold)`;
                activeQuestDisplay.style.display = 'block';
            } else {
                activeQuestDisplay.style.display = 'none';
            }
        }

        /**
         * Displays the game over screen and disables game input.
         */
        function gameOver() {
            gameOverScreen.style.display = 'flex'; //show game over screen
            townScreen.style.display = 'none'; // Hide town screen if open
            monsterEncounterScreen.style.display = 'none'; // Hide monster screen if open
            // Disable input
            disableGameInput();
        }

        /**
         * Resizes the canvas to fit the window and redraws the map.
         * Does not regenerate the map to preserve current game state.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawMap(); // Redraw the map to fit new dimensions
        }

        /**
         * Generates a new random map with various terrain types and towns.
         * Includes a second pass to cluster similar terrain types and generates roads between two random towns.
         */
        function generateMap() {
            mapData = [];
            townNames = {}; // Clear town names each time the map is generated
            let generatedTownNames = new Set(); // To ensure unique names
            townCoordinates = []; // Clear town coordinates

            // First pass: Randomly place terrain types
            for (let y = 0; y < mapHeight; y++) {
                mapData[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    const randomValue = Math.random();
                    if (randomValue < 0.1) { // 10% chance
                        mapData[y][x] = 1; // Mountain
                    } else if (randomValue < 0.3) { // 20% chance (cumulative, so 30% total)
                        mapData[y][x] = 2; // Forest
                    } else if (randomValue < 0.4) { // 10% chance (cumulative, so 40% total)
                        mapData[y][x] = 3; // Lake
                    } else if (randomValue < 0.41) { // 1% chance for towns (cumulative, so 41% total)
                        mapData[y][x] = 4; // Town
                    } else if (randomValue < 0.5) { // 9% chance for swamps (cumulative, so 50% total)
                        mapData[y][x] = 5; // Swamp
                    } else {
                        mapData[y][x] = 0; // Open space
                    }
                }
            }

            // Second pass: Cluster features based on neighbors
            const tempMapData = JSON.parse(JSON.stringify(mapData)); // Deep copy
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (tempMapData[y][x] === 0) { // Only apply to open spaces in the original map
                        let neighbors = [];
                        if (y > 0) neighbors.push(tempMapData[y - 1][x]);
                        if (y < mapHeight - 1) neighbors.push(tempMapData[y + 1][x]);
                        if (x > 0) neighbors.push(tempMapData[y][x - 1]);
                        if (x < mapWidth - 1) neighbors.push(tempMapData[y][x + 1]);

                        let mountainCount = neighbors.filter(n => n === 1).length;
                        let forestCount = neighbors.filter(n => n === 2).length;
                        let lakeCount = neighbors.filter(n => n === 3).length;
                        let swampCount = neighbors.filter(n => n === 5).length;

                        // If an open space has multiple neighbors of a certain type, it becomes that type
                        if (mountainCount > 1) mapData[y][x] = 1;
                        else if (forestCount > 1) mapData[y][x] = 2;
                        else if (lakeCount > 1) mapData[y][x] = 3;
                        else if (swampCount > 1) mapData[y][x] = 5;
                    }
                }
            }

            // Generate names for towns and collect their coordinates
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (mapData[y][x] === 4) {
                        let townName;
                        do {
                            townName = generateTownName();
                        } while (generatedTownNames.has(townName)); // Ensure uniqueness
                        generatedTownNames.add(townName);
                        townNames[`${x},${y}`] = townName; // Store name with coordinates
                        townCoordinates.push({ x: x, y: y }); // Store town coordinates
                    }
                }
            }

            // Generate road between two random towns
            if (townCoordinates.length >= 2) {
                const town1Index = Math.floor(Math.random() * townCoordinates.length);
                let town2Index;
                do {
                    town2Index = Math.floor(Math.random() * townCoordinates.length);
                } while (town2Index === town1Index); // Ensure different towns

                const town1 = townCoordinates[town1Index];
                const town2 = townCoordinates[town2Index];
                generateRoad(town1.x, town1.y, town2.x, town2.y);
            }
        }

        /**
         * Initializes the player's position on a random open space.
         * Centers the view on the player's starting position.
         */
        function initializePlayer() {
            let openSpaces = [];

            // Collect all empty spaces
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (mapData[y][x] === 0) { // Only place player on open space
                        openSpaces.push({ x: x, y: y });
                    }
                }
            }

            if (openSpaces.length > 0) {
                // Choose a random open space
                const randomIndex = Math.floor(Math.random() * openSpaces.length);
                playerX = openSpaces[randomIndex].x;
                playerY = openSpaces[randomIndex].y;
            } else {
                // Fallback if no open space found (shouldn't happen with current generation)
                playerX = Math.floor(mapWidth / 2);
                playerY = Math.floor(mapHeight / 2);
                console.warn("No open space found for player, placing at center.");
            }

            // Calculate the offset to center the map on the player
            viewOffsetX = playerX * gridSize - canvas.width / (2 * zoomLevel);
            viewOffsetY = playerY * gridSize - canvas.height / (2 * zoomLevel);
        }

        const townNameParts = [
            ["River", "Brook", "Creek", "Lake", "Falls", "Spring", "Stone", "Iron"],
            ["Wood", "Forest", "Grove", "Meadow", "Hill", "Mountain", "Dale", "Field"],
            ["Town", "City", "Village", "Hamlet", "Burg", "Fort", "Port", "Haven"]
        ];

        /**
         * Generates a random, unique town name.
         * @returns {string} The generated town name.
         */
        function generateTownName() {
            // Only use 2 parts for town names
            const part1Index = Math.floor(Math.random() * townNameParts[0].length);
            const part2Index = Math.floor(Math.random() * townNameParts[1].length);
            return townNameParts[0][part1Index] + townNameParts[1][part2Index];
        }

        /**
         * Generates a road between two given grid coordinates using Bresenham's line algorithm.
         * Roads are only placed on traversable terrain (open space, forest, swamp) and do not overwrite towns, mountains, or lakes.
         * @param {number} startX - X coordinate of the starting point.
         * @param {number} startY - Y coordinate of the starting point.
         * @param {number} endX - X coordinate of the ending point.
         * @param {number} endY - Y coordinate of the ending point.
         */
        function generateRoad(startX, startY, endX, endY) {
            let currentX = startX;
            let currentY = startY;
            const dx = Math.abs(endX - startX);
            const dy = Math.abs(endY - startY);
            const xDir = (endX > startX) ? 1 : -1;
            const yDir = (endY > startY) ? 1 : -1;

            let error = dx - dy;

            while (currentX !== endX || currentY !== endY) {
                // Only set road if the current tile is not a mountain (1), lake (3), or town (4)
                // Roads can be on open space (0), forest (2), or swamp (5)
                if (mapData[currentY][currentX] !== 1 && mapData[currentY][currentX] !== 3 && mapData[currentY][currentX] !== 4) {
                    mapData[currentY][currentX] = 6; // Road
                }

                const doubleError = error * 2;

                if (doubleError > -dy) {
                    error -= dy;
                    currentX += xDir;
                }
                if (doubleError < dx) {
                    error += dx;
                    currentY += yDir;
                }
            }
            // Set the end point as a road, but only if it's not a town, mountain, or lake
            if (mapData[currentY][currentX] !== 1 && mapData[currentY][currentX] !== 3 && mapData[currentY][currentX] !== 4) {
                mapData[currentY][currentX] = 6; // Road
            }
        }

        /**
         * Draws the map, player, and town names on the canvas.
         * Applies current zoom level and view offset for panning.
         */
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(zoomLevel, zoomLevel);

            // Calculate visible map area to optimize drawing
            const visibleStartX = Math.floor(viewOffsetX / gridSize / zoomLevel);
            const visibleStartY = Math.floor(viewOffsetY / gridSize / zoomLevel);
            const visibleEndX = Math.ceil((viewOffsetX + canvas.width) / gridSize / zoomLevel);
            const visibleEndY = Math.ceil((viewOffsetY + canvas.height) / gridSize / zoomLevel);

            // Draw the map tiles
            for (let y = Math.max(0, visibleStartY); y < Math.min(mapHeight, visibleEndY); y++) {
                for (let x = Math.max(0, visibleStartX); x < Math.min(mapWidth, visibleEndX); x++) {
                    switch (mapData[y][x]) {
                        case 1:
                            ctx.fillStyle = '#808080'; // Grey for mountains
                            break;
                        case 2:
                            ctx.fillStyle = '#228B22'; // Darker richer green for forests
                            break;
                        case 3:
                            ctx.fillStyle = '#3b82f6'; // Blue for lakes
                            break;
                        case 4:
                            ctx.fillStyle = '#ffff00'; // Yellow for towns
                            break;
                        case 5:
                            ctx.fillStyle = '#698339'; // Murky green for swamps
                            break;
                        case 6:
                            ctx.fillStyle = '#b89c7d'; // Road color (brownish)
                            break;
                        case 0:
                        default:
                            ctx.fillStyle = '#86ef7d'; // Grass green for open space
                            break;
                    }
                    // Draw each square 1 pixel larger to hide grid lines
                    ctx.fillRect(
                        x * gridSize - viewOffsetX / zoomLevel,
                        y * gridSize - viewOffsetY / zoomLevel,
                        gridSize + 1, // Increased size
                        gridSize + 1  // Increased size
                    );
                }
            }

            // Draw player, relative to the view offset
            const playerScreenX = playerX * gridSize - viewOffsetX / zoomLevel;
            const playerScreenY = playerY * gridSize - viewOffsetY / zoomLevel;
            ctx.fillStyle = '#ef4444'; // Red for player
            ctx.fillRect(playerScreenX, playerScreenY, gridSize, gridSize);
            ctx.strokeStyle = '#b91c1c'; // Darker red border
            ctx.strokeRect(playerScreenX, playerScreenY, gridSize, gridSize);

            // Draw town names
            ctx.fillStyle = '#000000'; // Black text for town names
            ctx.font = '12px Inter, sans-serif'; // Adjust font size and family as needed
            for (const [coords, name] of Object.entries(townNames)) {
                const [x, y] = coords.split(",").map(Number);
                const townX = x * gridSize - viewOffsetX / zoomLevel + gridSize / 2; // Center text
                const townY = y * gridSize - viewOffsetY / zoomLevel + gridSize + 14; // Position below town
                ctx.textAlign = 'center';
                ctx.fillText(name, townX, townY);
            }

            ctx.restore();
        }

        /**
         * Calculates the Manhattan distance between two grid points.
         * @param {number} x1 - X coordinate of the first point.
         * @param {number} y1 - Y coordinate of the first point.
         * @param {number} x2 - X coordinate of the second point.
         * @param {number} y2 - Y coordinate of the second point.
         * @returns {number} The Manhattan distance.
         */
        function calculateDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        /**
         * Generates three random delivery quests.
         */
        function generateDeliveryQuests() {
            availableQuests = [];
            const currentTownCoords = { x: playerX, y: playerY };

            for (let i = 0; i < 3; i++) {
                let targetTown = null;
                let distance = 0;
                let attempts = 0;
                
                while (attempts < maxDeliveryAttempts) {
                    const randomIndex = Math.floor(Math.random() * townCoordinates.length);
                    const potentialTargetTown = townCoordinates[randomIndex];

                    // Ensure target town is not the current town and is far enough
                    if (potentialTargetTown.x !== currentTownCoords.x || potentialTargetTown.y !== currentTownCoords.y) {
                        const dist = calculateDistance(currentTownCoords.x, currentTownCoords.y, potentialTargetTown.x, potentialTargetTown.y);
                        if (dist >= minDeliveryDistance) {
                            targetTown = potentialTargetTown;
                            distance = dist;
                            break;
                        }
                    }
                    attempts++;
                }

                if (targetTown) {
                    const reward = Math.floor(distance * deliveryRewardFactor);
                    availableQuests.push({
                        targetX: targetTown.x,
                        targetY: targetTown.y,
                        reward: reward,
                        targetTownName: townNames[`${targetTown.x},${targetTown.y}`],
                        distance: distance
                    });
                } else {
                    // If no suitable town found after attempts, add a placeholder or skip
                    availableQuests.push(null); 
                }
            }
            // Populate buttons
            availableQuests.forEach((quest, index) => {
                if (quest) {
                    // Removed "units" from the display string
                    deliveryOptionButtons[index].textContent = `Deliver to ${quest.targetTownName} for ${quest.reward} Gold`;
                    deliveryOptionButtons[index].onclick = () => takeDeliveryQuest(index);
                    deliveryOptionButtons[index].style.display = 'block';
                } else {
                    deliveryOptionButtons[index].textContent = `No delivery available`;
                    deliveryOptionButtons[index].onclick = null;
                    deliveryOptionButtons[index].disabled = true; // Disable if no quest
                    deliveryOptionButtons[index].style.display = 'block';
                }
            });
        }

        /**
         * Sets the chosen delivery quest as the current active quest.
         * @param {number} questIndex - The index of the selected quest in availableQuests.
         */
        function takeDeliveryQuest(questIndex) {
            currentQuest = availableQuests[questIndex];
            showMessage(`Quest accepted: Deliver to ${currentQuest.targetTownName}!`, 3000);
            updateActiveQuestDisplay();
            closeTownScreen();
        }

        /**
         * Starts a monster encounter.
         */
        function startMonsterEncounter() {
            isMonsterEncounterActive = true;
            disableGameInput();
            townScreen.style.display = 'none'; // Ensure town screen is hidden
            gameOverScreen.style.display = 'none'; // Ensure game over is hidden

            // Define a simple monster (can be expanded to random monsters)
            currentMonster = {
                name: "Goblin",
                health: 50,
                attack: 15,
                goldReward: 15, // Gold gained on defeat
                foodReward: 0 // Food gained on defeat
            };

            monsterNameDisplay.textContent = currentMonster.name;
            monsterHealthDisplay.textContent = `Health: ${currentMonster.health}`;
            monsterMessageDisplay.textContent = `A wild ${currentMonster.name} appears!`;

            monsterEncounterScreen.style.display = 'flex';
        }

        /**
         * Handles the player fighting the monster.
         */
        function fightMonster() {
            if (!currentMonster) return;

            let battleMessage = "";

            // Player attacks
            currentMonster.health -= playerBaseAttack;
            battleMessage += `You hit the ${currentMonster.name} for ${playerBaseAttack} damage! `;

            if (currentMonster.health <= 0) {
                battleMessage += `The ${currentMonster.name} is defeated! `;
                if (currentMonster.goldReward > 0) {
                    goldCount += currentMonster.goldReward;
                    battleMessage += `You gained ${currentMonster.goldReward} gold.`;
                }
                if (currentMonster.foodReward > 0) {
                    foodCount += currentMonster.foodReward;
                    battleMessage += `You gained ${currentMonster.foodReward} food.`;
                }
                updateGoldCounter();
                updateFoodCounter();
                showMessage(battleMessage, 3000);
                endMonsterEncounter();
                return;
            }

            // Monster attacks
            healthCount = Math.max(0, healthCount - currentMonster.attack); // Ensure health doesn't go below 0
            battleMessage += `The ${currentMonster.name} hits you for ${currentMonster.attack} health!`;
            updateHealthCounter();

            monsterHealthDisplay.textContent = `Health: ${currentMonster.health}`;
            monsterMessageDisplay.textContent = battleMessage;

            if (healthCount <= 0) {
                gameOverReason.textContent = "You ran out of health battling the monster!";
                gameOver();
                endMonsterEncounter(); // Ensure screen is hidden
            }
        }

        /**
         * Handles the player running from the monster.
         */
        function runFromMonster() {
            let runMessage = "";
            if (Math.random() < playerRunSuccessChance) {
                healthCount = Math.max(0, healthCount - runHealthPenalty); // Ensure health doesn't go below 0
                updateHealthCounter();
                runMessage = `You successfully escaped the ${currentMonster.name}, but lost ${runHealthPenalty} health in the process.`;
                showMessage(runMessage, 3000);
                endMonsterEncounter();
            } else {
                healthCount = Math.max(0, healthCount - monsterHitHealthLoss); // Ensure health doesn't go below 0
                goldCount = Math.max(0, goldCount - monsterHitGoldLoss); // Ensure gold doesn't go below 0
                updateHealthCounter();
                updateGoldCounter();
                runMessage = `You failed to escape the ${currentMonster.name} and took ${monsterHitHealthLoss} health damage and lost ${monsterHitGoldLoss} gold!`;
                showMessage(runMessage, 3000);
                if (healthCount <= 0) { // Only health leads to game over now
                    gameOverReason.textContent = "You ran out of health trying to escape the monster!";
                    gameOver();
                }
                endMonsterEncounter(); // End encounter regardless of success/failure
            }
        }

        /**
         * Ends the monster encounter and returns to map.
         */
        function endMonsterEncounter() {
            isMonsterEncounterActive = false;
            currentMonster = null;
            monsterEncounterScreen.style.display = 'none';
            enableGameInput();
            drawMap(); // Redraw map to reflect any changes
        }

        /**
         * Updates the displayed health amount and gold cost based on the healing slider's value.
         */
        function updateHealSliderDisplay() {
            const healthToHeal = parseInt(healthHealSlider.value);
            const goldCost = healthToHeal / healthPerGoldUnitHeal;
            sliderHealthAmountDisplay.textContent = `${healthToHeal} Health`;
            sliderHealCostDisplay.textContent = `${goldCost} Gold`;

            // Disable heal button if cost is too high or healthToHeal is 0 or health is full
            if (healthToHeal === 0 || goldCount < goldCost || healthCount >= maxHealthCapacity) {
                healHealthButton.disabled = true;
                healHealthButton.classList.add('opacity-50', 'cursor-not-allowed');
                healHealthButton.classList.remove('hover:bg-red-700', 'transform', 'hover:scale-105');
            } else {
                healHealthButton.disabled = false;
                healHealthButton.classList.remove('opacity-50', 'cursor-not-allowed');
                healHealthButton.classList.add('hover:bg-red-700', 'transform', 'hover:scale-105');
            }
        }

        /**
         * Handles healing health in the town.
         */
        function healHealth() {
            const healthToHeal = parseInt(healthHealSlider.value);
            const goldCost = healthToHeal / healthPerGoldUnitHeal;

            if (healthToHeal === 0) {
                showMessage("Please select an amount of health to heal.", 2000);
                return;
            }

            if (goldCount >= goldCost) {
                goldCount -= goldCost;
                healthCount += healthToHeal;
                // Cap healthCount at maxHealthCapacity
                healthCount = Math.min(healthCount, maxHealthCapacity);

                updateHealthCounter();
                updateGoldCounter();
                showMessage(`You healed ${healthToHeal} health for ${goldCost} gold!`, 2500);
                // Update slider max and display after purchase
                showTownScreen(townNames[`${playerX},${playerY}`]);
            } else {
                showMessage("Not enough gold to heal that much health!", 2500);
            }
        }

        /**
         * Updates the displayed food amount and gold cost based on the slider's value.
         */
        function updateSliderDisplay() {
            const foodToBuy = parseInt(foodBuySlider.value);
            const goldCost = foodToBuy / foodPerGoldUnit;
            sliderFoodAmountDisplay.textContent = `${foodToBuy} Food`;
            sliderGoldCostDisplay.textContent = `${goldCost} Gold`;

            // Disable buy button if cost is too high or foodToBuy is 0
            if (foodToBuy === 0 || goldCount < goldCost) {
                buyFoodButton.disabled = true;
                buyFoodButton.classList.add('opacity-50', 'cursor-not-allowed');
                buyFoodButton.classList.remove('hover:bg-green-700', 'transform', 'hover:scale-105');
            } else {
                buyFoodButton.disabled = false;
                buyFoodButton.classList.remove('opacity-50', 'cursor-not-allowed');
                buyFoodButton.classList.add('hover:bg-green-700', 'transform', 'hover:scale-105');
            }
        }

        /**
         * Displays the town interaction screen.
         * @param {string} name - The name of the town to display.
         */
        function showTownScreen(name) {
            townNameDisplay.textContent = name;
            
            // Calculate max food player can buy based on current food and max capacity
            const maxBuyableFoodByCapacity = maxFoodCapacity - foodCount;
            // Calculate max food player can buy based on current gold
            const maxBuyableFoodByGold = Math.floor(goldCount * foodPerGoldUnit);

            // Set food slider max
            const sliderFoodMax = Math.max(0, Math.floor(Math.min(maxBuyableFoodByCapacity, maxBuyableFoodByGold) / 10) * 10);
            foodBuySlider.max = sliderFoodMax;
            foodBuySlider.value = 0; // Start slider at 0
            updateSliderDisplay(); // Update food slider display initially

            // Calculate max health player can heal based on current health and max capacity
            const maxHealableHealth = maxHealthCapacity - healthCount;
            // Calculate max health player can heal based on current gold
            const maxHealableHealthByGold = Math.floor(goldCount * healthPerGoldUnitHeal);

            // Set health slider max, ensuring it's a multiple of 2
            const sliderHealthMax = Math.max(0, Math.floor(Math.min(maxHealableHealth, maxHealableHealthByGold) / 2) * 2);
            healthHealSlider.max = sliderHealthMax;
            healthHealSlider.value = 0; // Start slider at 0
            updateHealSliderDisplay(); // Update health slider display initially

            // Only generate and show delivery quests if no quest is active
            if (!currentQuest) {
                generateDeliveryQuests();
                deliveryOptionButtons.forEach(btn => btn.style.display = 'block');
                // Removed noDeliveryButton.style.display = 'block';
            } else {
                deliveryOptionButtons.forEach(btn => btn.style.display = 'none');
                // Removed noDeliveryButton.style.display = 'none';
            }

            townScreen.style.display = 'flex';
            // Disable game input
            disableGameInput();
        }

        /**
         * Handles buying food in the town.
         */
        function buyFood() {
            const foodToBuy = parseInt(foodBuySlider.value);
            const goldCost = foodToBuy / foodPerGoldUnit;

            if (foodToBuy === 0) {
                showMessage("Please select an amount of food to buy.", 2000);
                return;
            }

            if (goldCount >= goldCost) {
                goldCount -= goldCost;
                foodCount += foodToBuy;
                // Cap foodCount at maxFoodCapacity
                foodCount = Math.min(foodCount, maxFoodCapacity);

                updateFoodCounter();
                updateGoldCounter();
                showMessage(`You bought ${foodToBuy} food for ${goldCost} gold!`, 2500);
                // Update slider max and display after purchase
                showTownScreen(townNames[`${playerX},${playerY}`]);
            } else {
                showMessage("Not enough gold to buy that much food!", 2500);
            }
        }

        /**
         * Closes the town interaction screen and re-enables game input.
         */
        function closeTownScreen() {
            townScreen.style.display = 'none';
            // Re-enable game input
            enableGameInput();
            drawMap(); // Redraw map to ensure player is visible
        }

        /**
         * Disables all game input listeners.
         */
        function disableGameInput() {
            window.removeEventListener('keydown', handleKeyDown);
            canvas.removeEventListener('mousedown', handleMouseDown);
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseup', handleMouseUp);
            canvas.removeEventListener('mouseleave', handleMouseLeave);
            canvas.removeEventListener('wheel', handleMouseWheel);
            canvas.removeEventListener('touchstart', handleTouchStart);
            canvas.removeEventListener('touchmove', handleTouchMove);
            canvas.removeEventListener('touchend', handleTouchEnd);
        }

        /**
         * Enables all game input listeners.
         */
        function enableGameInput() {
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave);
            canvas.addEventListener('wheel', handleMouseWheel);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }

        /**
         * Restarts the game, resetting food/gold, regenerating the map, and re-enabling input.
         */
        function restartGame() {
            gameOverScreen.style.display = 'none'; //hide game over screen
            townScreen.style.display = 'none'; // Hide town screen if open
            monsterEncounterScreen.style.display = 'none'; // Hide monster screen if open
            currentQuest = null; // Clear any active quest
            updateActiveQuestDisplay(); // Hide quest display
            turnsInHazardousTerrain = 0; // Reset monster encounter counter
            enableGameInput(); //re-enable input

            foodCount = 100; //reset food
            goldCount = 10; // Reset gold
            healthCount = 100; // Reset health
            updateHealthCounter(); // Update health display
            updateFoodCounter();
            updateGoldCounter();
            generateMap();
            initializePlayer();
            resizeCanvas(); // Ensure canvas is correctly sized and map drawn
            drawMap();
        }

        /**
         * Handles keyboard input for player movement.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDown(event) {
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    movePlayer(1, 0);
                    break;
            }
        }

        /**
         * Attempts to move the player by the given delta coordinates.
         * Handles terrain interactions, food/gold consumption, and game over conditions.
         * @param {number} dx - Change in X coordinate.
         * @param {number} dy - Change in Y coordinate.
         */
        function movePlayer(dx, dy) {
            // Prevent movement if an encounter is active
            if (isMonsterEncounterActive) {
                showMessage("You must deal with the monster first!", 1500);
                return;
            }

            const newX = playerX + dx;
            const newY = playerY + dy;

            // Check boundaries
            if (newX < 0 || newX >= mapWidth || newY < 0 || newY >= mapHeight) {
                showMessage("You can't go off the map!", 1500);
                return; // Cannot move off map
            }

            const targetTileType = mapData[newY][newX];
            let movementCost = 1; // Base food cost for moving
            let canMove = true;
            let message = "";

            // Check for quest completion first
            if (currentQuest && newX === currentQuest.targetX && newY === currentQuest.targetY) {
                goldCount += currentQuest.reward;
                showMessage(`Delivery complete! You earned ${currentQuest.reward} gold for delivering to ${currentQuest.targetTownName}!`, 3000);
                currentQuest = null; // Clear the quest
                updateGoldCounter();
                updateActiveQuestDisplay(); // Hide active quest display
                // Player still moves onto the town, so proceed with town logic
                playerX = newX;
                playerY = newY;
                showTownScreen(townNames[`${newX},${newY}`]); // Show town screen
                turnsInHazardousTerrain = 0; // Reset counter when entering town
                return; // Exit movePlayer, as town screen handles further actions
            }

            switch (targetTileType) {
                case 1: // Mountain
                    canMove = false;
                    message = "Mountains are impassable!";
                    break;
                case 3: // Lake
                    canMove = false;
                    message = "Lakes are too deep to cross!";
                    break;
                case 2: // Forest
                    movementCost = 2; // More food
                    message = "You trek through the dense forest.";
                    if (Math.random() < 0.2) { // 20% chance to find food
                        foodCount += 10;
                        message += " You found some berries!";
                    }
                    // Removed gold finding in forests
                    break;
                case 4: // Town (if not a quest target)
                    playerX = newX; // Update player position before showing town screen
                    playerY = newY;
                    showTownScreen(townNames[`${newX},${newY}`]); // Call new function
                    turnsInHazardousTerrain = 0; // Reset counter when entering town
                    return; // Exit movePlayer, as town screen handles further actions
                case 5: // Swamp
                    movementCost = 3; // Even more food
                    message = "The murky swamp slows you down.";
                    if (Math.random() < 0.15) { // 15% chance to lose gold
                        goldCount = Math.max(0, goldCount - Math.min(goldCount, 10)); // Ensure gold doesn't go below 0
                        message += ` You lost ${Math.min(goldCount, 10)} gold in the murky waters!`;
                    }
                    break;
                case 6: // Road
                    movementCost = 0.5; // Less food
                    message = "You travel swiftly on the road.";
                    break;
                case 0: // Open Space
                default:
                    movementCost = 1;
                    message = "You traverse the open plains.";
                    break;
            }

            if (!canMove) {
                showMessage(message, 1500);
                return;
            }

            // Apply movement cost
            foodCount = Math.max(0, foodCount - movementCost); // Ensure food doesn't go below 0
            updateFoodCounter();
            updateGoldCounter();

            // New: Health penalty if food is 0
            if (foodCount <= 0) {
                healthCount = Math.max(0, healthCount - noFoodHealthPenalty); // Ensure health doesn't go below 0
                updateHealthCounter();
                showMessage(`You have no food! You lose ${noFoodHealthPenalty} health!`, 2500);
            }

            // Check for game over conditions (only health now)
            if (healthCount <= 0) {
                gameOverReason.textContent = "You have run out of health!";
                gameOver();
                return;
            }

            playerX = newX;
            playerY = newY;
            showMessage(message, 2500); // Show message after successful move

            // Check for monster encounter after movement and message
            if (targetTileType === 2 || targetTileType === 5) { // Forest or Swamp
                turnsInHazardousTerrain++;
                let encounterChance = baseEncounterChance + (turnsInHazardousTerrain * chanceIncreasePerTurn);
                encounterChance = Math.min(encounterChance, maxEncounterChance); // Cap the chance

                if (Math.random() < encounterChance) {
                    startMonsterEncounter();
                    return; // Stop further movement processing until encounter is resolved
                }
            } else {
                turnsInHazardousTerrain = 0; // Reset counter if not in hazardous terrain
            }

            // Recenter view if player goes off-screen (with a buffer)
            const playerScreenX = playerX * gridSize - viewOffsetX / zoomLevel;
            const playerScreenY = playerY * gridSize - viewOffsetY / zoomLevel;

            const screenBuffer = 0.2; // 20% buffer
            const screenWidth = canvas.width / zoomLevel;
            const screenHeight = canvas.height / zoomLevel;

            if (playerScreenX < screenWidth * screenBuffer || playerScreenX > screenWidth * (1 - screenBuffer) ||
                playerScreenY < screenHeight * screenBuffer || playerScreenY > screenHeight * (1 - screenBuffer)) {
                viewOffsetX = playerX * gridSize - canvas.width / (2 * zoomLevel);
                viewOffsetY = playerY * gridSize - canvas.height / (2 * zoomLevel);
            }
            drawMap();
        }

        /**
         * Handles mouse down events for dragging the map.
         * @param {MouseEvent} event - The mouse event.
         */
        function handleMouseDown(event) {
            isDragging = true;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            canvas.style.cursor = 'grabbing';
        }

        /**
         * Handles mouse move events for dragging the map.
         * @param {MouseEvent} event - The mouse event.
         */
        function handleMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            viewOffsetX -= deltaX / zoomLevel;
            viewOffsetY -= deltaY / zoomLevel;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            drawMap();
        }

        /**
         * Handles mouse up events, ending the dragging state.
         */
        function handleMouseUp() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        /**
         * Handles mouse leave events, ending the dragging state if the mouse leaves the canvas.
         */
        function handleMouseLeave() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        /**
         * Handles mouse wheel events for zooming in and out.
         * @param {WheelEvent} event - The wheel event.
         */
        function handleMouseWheel(event) {
            event.preventDefault(); // Prevent page scroll

            const oldZoomLevel = zoomLevel;
            if (event.deltaY < 0) { // Scrolling up, zoom in
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomSpeed);
            } else if (event.deltaY > 0) { // Scrolling down, zoom out
                zoomLevel = Math.max(minZoom, zoomLevel - zoomSpeed);
            }

            // Adjust view offset to zoom towards the mouse cursor
            const mouseX = event.clientX;
            const mouseY = event.clientY;

            viewOffsetX += (mouseX / oldZoomLevel) - (mouseX / zoomLevel);
            viewOffsetY += (mouseY / oldZoomLevel) - (mouseY / zoomLevel);

            drawMap();
        }

        let touchStartX, touchStartY;
        let lastTouchX, lastTouchY; // For continuous panning on touchmove

        /**
         * Handles touch start events for panning and preparing for swipe movement.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent scrolling
            isDragging = true;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            lastTouchX = touchStartX; // Initialize for panning
            lastTouchY = touchStartY; // Initialize for panning
            canvas.style.cursor = 'grabbing';
        }

        /**
         * Handles touch move events for panning the map.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (!isDragging) return;
            const currentX = event.touches[0].clientX;
            const currentY = event.touches[0].clientY;
            const deltaX = currentX - lastTouchX;
            const deltaY = currentY - lastTouchY;
            viewOffsetX -= deltaX / zoomLevel;
            viewOffsetY -= deltaY / zoomLevel;
            lastTouchX = currentX;
            lastTouchY = currentY;
            drawMap();
        }

        /**
         * Handles touch end events for determining swipe gestures for player movement.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchEnd(event) {
            isDragging = false;
            canvas.style.cursor = 'grab';

            // Implement swipe for movement if not a significant drag
            if (event.changedTouches.length > 0) {
                const endX = event.changedTouches[0].clientX;
                const endY = event.changedTouches[0].clientY;

                const swipeThreshold = 30; // Minimum distance for a swipe

                const deltaX = endX - touchStartX;
                const deltaY = endY - touchStartY;

                // Check if it was primarily a swipe, not just a tap or small drag
                if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            movePlayer(1, 0); // Right
                        } else {
                            movePlayer(-1, 0); // Left
                        }
                    } else {
                        // Vertical swipe
                        if (deltaY > 0) {
                            movePlayer(0, 1); // Down
                        } else {
                            movePlayer(0, -1); // Up
                        }
                    }
                }
            }
        }

        // Event Listeners
        restartButton.addEventListener('click', restartGame);
        buyFoodButton.addEventListener('click', buyFood);
        closeTownButton.addEventListener('click', closeTownScreen);
        foodBuySlider.addEventListener('input', updateSliderDisplay); // Listen for food slider changes

        // New event listeners for health healing
        healthHealSlider.addEventListener('input', updateHealSliderDisplay);
        healHealthButton.addEventListener('click', healHealth);

        // Removed noDeliveryButton.addEventListener('click', closeTownButton);

        // Add event listeners for delivery options
        deliveryOptionButtons.forEach((button, index) => {
            button.addEventListener('click', () => {
                if (availableQuests[index]) { // Ensure a quest exists at this index
                    takeDeliveryQuest(index);
                }
            });
        });

        // Monster encounter buttons
        fightButton.addEventListener('click', fightMonster);
        runButton.addEventListener('click', runFromMonster);

        // Initial input setup
        enableGameInput();

        // Initial setup when the window loads
        window.addEventListener('load', () => {
            generateMap(); // Generate map initially
            initializePlayer(); // Place player
            resizeCanvas(); // Set canvas size and draw map
            updateHealthCounter(); // Update health display
            updateFoodCounter();
            updateGoldCounter();
            updateActiveQuestDisplay(); // Initialize quest display
        });

        // Handle window resize events
        window.addEventListener('resize', () => {
            resizeCanvas(); // Handle resizes
        });
    </script>
</body>
</html>
